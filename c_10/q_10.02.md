# 「世界で闘うプログラミング力を鍛える150問」問題10.2

## 問題

FacebookやLinkedInのような、
非常に大きなソーシャルネットワークのデータ構造をどのように設計しますか?
また、2人のユーザー間のつながり (私→ボブ→スーザン→ジェイソン→あなた、のような) を
示すアルゴリズムをどのように設計すればよいか説明してください。

## 回答

制約を考慮せず簡単な手法から考える。

### 問題を単純化する - ユーザーが数百万もいるということは忘れてしまう

    class Person
    {
    	std::string user_name_;
    	std::vector<Person*> friends_; // 規模は考えない
    };

ユーザ間のつながりは幅優先探索で深さを制限して処理する。
(深さ優先探索するといつまでたっても処理が終わらない)

### 数百万のユーザーを扱う

ユーザーをIDで扱うようにする。
また、どのユーザーがどのサーバ上で管理されているか分かるようにする。

    class Person
    {
    private:
    
    	std::string id_;
    	std::string user_name_;
    	std::vector<std::string> friends_;  // ユーザーをIDで扱う
    
    public:

    	...  // アクセッサなど
    };

    class Server
    {
    private:
    
    	static std::unordered_map<std::string, Server*> servers_;  // DBで持っておくべき
    
    	std::string id_;
    	std::string server_name_;
    	std::unordered_map<std::string, Person*> users_;  // DBで持っておくべき
    
    public:
    
    	static Server* GetServer(std::string user_id)
    	{
    		...
    	}
    
    	Person* get_user(std::string user_id) const
    	{
    		...	// DBから取得すべき
    	}
    };

### 最適化: マシン間の移動を少なくする

サーバ間のデータ移動は高コストであることから、なるべく避けたい。
このことから、
何らかの理由でユーザー・インスタンスを他サーバに移すことになったら、
移すユーザー数がある一定以上になるまで実施を先延ばしにする。

### 最適化: ユーザーとマシンの細分化

SNSのユーザーの多くが同一地区に住む知人とリンク関係にあると考えられる。
また、多くのユーザーは年の近い知人が多いと考えられる。
このことから、
同一の州や国ごとにサーバーをまとめれば、
また、世代ごとにサーバーをまとめれば、
やりとりがサーバー内で収まることが多くなると考えられる。

## 発展問題

幅優先探索ではノード・クラスにすでに調べたかどうかを表すフラグを用意するが、
今回は並列処理になるためにノード・クラスにフラグを含めることは避けたいです。
どのようにすれば良いでしょうか?

## 発展問題の回答

ハッシュ・テーブルを使って処理する。

## その他の発展問題

* 運用中のサーバーに障害が発生します。どのような影響が考えられますか?
* キャッシュを有効に利用することはできますか?
* グラフは完全に探索しますか?
  あるいはどのように探索を終わらせますか?
* 実データではユーザーごとの友人の総数にばらつきがあります。
  このばらつきを考慮し、どこから探索を行いますか?
